# Unit Tests

Unit test
: a local test that runs and verifies the behavior of a small section of code in isolation.

Unit tests are the easiest and quickest tests to write.

Unit tests are simple but require:

- The code under test to be accessible from a test. Private methods cannot be directly tested. Instead, they must be tested via its public APIs.
- Testing in isolation requires that dependencies be replaced with components that you control, such fakes and other test doubles.

## Unit Test Requirements

Test must:

- be a class located in the `test source sets`
- contain functions annotated with `@Test`
- usually contain assertion statements

## Dependencies

Android uses JUnit for testing, which provides `@Test` annotation and assertions.

The following Dependencies need to be added to the module's `build.gradle` file using the `testImplementation` function to apply the them to the local test source set, and not to the application.

Dependencies for local unit tests:

```gradle
// Required -- JUnit 4 framework
testImplementation "junit:junit:$junitVersion"

// Optional -- Robolectric environment
testImplementation "androidx.test.core:$androidXTestVersion"

// Optional -- Mockito framework
testImplementation "org.mockito:mockito-core:$mockitoVersion"
```

> Note: `testImplementation` adds dependencies for local tests and `androidTestImplementation` adds dependencies for Instrumented tests.

## Local test location

Local test are placed stored in the `module-name/sr/tes/` directory which is generated by Android Studio when creating a new project.

## Writing Unit Tests

Local tests are written as JUnit 4 test classes.

```kotlin
// a test class is just a normal class
class ExampleTest {
    // each test is annotated with @Test (this is a Junit annotation)
    @Test
    fun addition_isCorrect() {
        // plain old Junit
        assertEquals(4, 2 + 2)

        // with [Hamcrest](http://hamcrest.org/JavaHamcrest/tutorial)
        assertThat(2 + 2, `is`(4))
    }
}
```

## Mocking dependencies

To mock an object for a local unit test use the `Mockito` framework.

1. Include Mockito in your `build.gradle` file.
2. Annotate the test class with @RunWith(MockitoJUnitRunner.class).
3. Add the @Mock annotation before the field declaration.
4. Stub the behavior of the dependency by specifying the conditions and return values using `when()` and `thenReturn()`.

## Mocking Context

```kotlin
private const val FAKE_STRING = "Hello, world!"

@RunWith(MockitoJUnitRunner::class)
class MockedContextTest {

    @Mock
    private lateinit var mockContext: Context

    @Test
    fun `read string from context`() {
        // Given
        `when`(mockContext.getString(R.string.name_labe))
            .thenReturn(FAKE_STRING)
        val myObjectUnderTest = ClassUnderTest(mockContext)

        // When
        val result = myObjectUnderTest.getName()

        // Then
        assertEquals(result, FAKE_STRING)
    }
}
```

## Error: "Method .. not mocked"

The Mockable Android library throw an exception if you try and access any of its methods.

To return defaults instead add the following to the project's `build.gradle` file:

```kotlin
andriod {
    ...
    testOptions.unitTests {
        returnDefaultValues = true
    }
}

```

> `returnDefaultValues` can cause regressions. Use only as a last resort.

## AndroidX Test APIs

work for both Unit Tests and Instrumented tests

`ApplicationProvider.getApplicationContext()`

Robolectric
: simulated Android environment for local tests

required for

```gradle
  testOptions.unitTests {
        includeAndroidResources = true

        // ...
    }
```

## Testing exceptions

The expected parameter of the JUnit test annotation can be used to check if code throws an expected exception.
`@Test(expected = IllegalArgumentException::class)`

## Before

@Before use before setup

```kotlin
// Subject under test
private lateinit var tasksViewModel: TasksViewModel

@Before
fun setupViewModel() {
    tasksViewModel = TasksViewModel(ApplicationProvider.getApplicationContext())
}
```

## Other Junit Annotations

JUnit also has other similar annotations:

- `@After`: The method will be executed after each test. You can use it to tear down anything or reset any objects that you set up in @Before.
- `@BeforeClass`: If you annotate a method with this, itâ€™ll be executed only once before all the tests are executed. For example, opening a file, a connection or a database that is shared in all the tests.
- `@AfterClass`: Use this one to execute a method only once after all the tests are executed. For example, closing a file, a connection or a database that is shared in all the tests.
